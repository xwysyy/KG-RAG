"""Tests for Neo4jGraphStore.upsert_node dual-label logic."""

import copy

import pytest
from unittest.mock import AsyncMock, MagicMock, patch


def _make_store():
    """Create a Neo4jGraphStore with a mocked driver/session."""
    from kg_rag.storage.neo4j_graph import Neo4jGraphStore

    store = Neo4jGraphStore()

    mock_result = AsyncMock()
    mock_result.consume = AsyncMock()

    mock_session = AsyncMock()
    mock_session.run = AsyncMock(return_value=mock_result)
    mock_session.__aenter__ = AsyncMock(return_value=mock_session)
    mock_session.__aexit__ = AsyncMock(return_value=False)

    mock_driver = MagicMock()
    mock_driver.session.return_value = mock_session

    store._driver = mock_driver
    return store, mock_session


class TestUpsertNode:
    """Verify Cypher generated by upsert_node for each label branch."""

    @pytest.mark.asyncio
    async def test_known_type_algorithm(self):
        store, session = _make_store()
        await store.upsert_node("id1", {"label": "Algorithm", "name": "BFS"})

        cypher = session.run.call_args.args[0]
        kwargs = session.run.call_args.kwargs
        assert "MERGE (n:Entity {entity_id: $eid})" in cypher
        assert "SET n:Algorithm" in cypher
        assert kwargs["props"]["type"] == "Algorithm"
        assert kwargs["props"]["name"] == "BFS"

    @pytest.mark.asyncio
    async def test_known_type_does_not_overwrite_existing_type(self):
        store, session = _make_store()
        await store.upsert_node(
            "id2", {"label": "Algorithm", "name": "BFS", "type": "Algo"}
        )

        kwargs = session.run.call_args.kwargs
        # setdefault should preserve the caller-provided "type"
        assert kwargs["props"]["type"] == "Algo"

    @pytest.mark.asyncio
    async def test_unknown_type_fallback(self):
        store, session = _make_store()
        await store.upsert_node("id3", {"label": "SomeNewType", "name": "X"})

        cypher = session.run.call_args.args[0]
        kwargs = session.run.call_args.kwargs
        assert "MERGE (n:Entity {entity_id: $eid})" in cypher
        assert "SET n:SomeNewType" not in cypher
        assert kwargs["props"]["type"] == "SomeNewType"

    @pytest.mark.asyncio
    async def test_base_label_entity(self):
        store, session = _make_store()
        await store.upsert_node("id4", {"label": "Entity", "name": "Foo"})

        cypher = session.run.call_args.args[0]
        assert "MERGE (n:Entity {entity_id: $eid})" in cypher
        # No extra SET n:<label>
        assert "SET n:" not in cypher

    @pytest.mark.asyncio
    async def test_base_label_user(self):
        store, session = _make_store()
        await store.upsert_node("u1", {"label": "User", "user_id": "u1"})

        cypher = session.run.call_args.args[0]
        assert "MERGE (n:User {user_id: $eid})" in cypher

    @pytest.mark.asyncio
    async def test_no_label_defaults_to_entity(self):
        store, session = _make_store()
        await store.upsert_node("id5", {"name": "Bar"})

        cypher = session.run.call_args.args[0]
        assert "MERGE (n:Entity {entity_id: $eid})" in cypher

    @pytest.mark.asyncio
    async def test_does_not_mutate_caller_dict(self):
        store, _ = _make_store()
        original = {"label": "Algorithm", "name": "BFS"}
        snapshot = copy.deepcopy(original)
        await store.upsert_node("id6", original)

        assert original == snapshot


class TestUpsertEdge:
    """Verify upsert_edge relation type allowlist logic."""

    @pytest.mark.asyncio
    async def test_known_rel_type(self):
        store, session = _make_store()
        await store.upsert_edge("src", "tgt", {"type": "PREREQ", "weight": 1.0})

        cypher = session.run.call_args.args[0]
        assert "MERGE (a)-[r:PREREQ]->(b)" in cypher

    @pytest.mark.asyncio
    async def test_unknown_rel_remapped(self):
        store, session = _make_store()
        await store.upsert_edge("src", "tgt", {"type": "FOOBAR", "weight": 1.0})

        cypher = session.run.call_args.args[0]
        assert "MERGE (a)-[r:RELATED_TO]->(b)" in cypher
        kwargs = session.run.call_args.kwargs
        assert kwargs["props"]["original_type"] == "FOOBAR"


class TestReadQueries:
    """Verify read queries include :Entity label constraint."""

    @pytest.mark.asyncio
    async def test_has_node_uses_entity_label(self):
        store, session = _make_store()
        await store.has_node("n1")
        cypher = session.run.call_args.args[0]
        assert "MATCH (n:Entity {entity_id: $eid})" in cypher

    @pytest.mark.asyncio
    async def test_get_node_uses_entity_label(self):
        store, session = _make_store()
        await store.get_node("n1")
        cypher = session.run.call_args.args[0]
        assert "MATCH (n:Entity {entity_id: $eid})" in cypher

    @pytest.mark.asyncio
    async def test_delete_node_uses_entity_label(self):
        store, session = _make_store()
        await store.delete_node("n1")
        cypher = session.run.call_args.args[0]
        assert "MATCH (n:Entity {entity_id: $eid})" in cypher

    @pytest.mark.asyncio
    async def test_has_edge_uses_entity_label(self):
        store, session = _make_store()
        await store.has_edge("s1", "t1")
        cypher = session.run.call_args.args[0]
        assert ":Entity {entity_id: $src})" in cypher
        assert ":Entity {entity_id: $tgt})" in cypher

    @pytest.mark.asyncio
    async def test_get_edge_uses_entity_label(self):
        store, session = _make_store()
        await store.get_edge("s1", "t1")
        cypher = session.run.call_args.args[0]
        assert ":Entity {entity_id: $src})" in cypher
        assert ":Entity {entity_id: $tgt})" in cypher
